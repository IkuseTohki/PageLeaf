# 技術仕様：アーキテクチャ設計規約

![PageLeaf Architecture](../assets/architecture_diagram.svg)

## 1. レイヤー分離とコード構造の対応

本プロジェクトはクリーンアーキテクチャに基づき、以下の通りコードを配置する。依存関係は常に下表の「上位」から「下位」へと向かう一方向（外側から内側）とする。中心にあるドメインモデルがもっとも重要であり、ビジネスルールを保持する。

| レイヤー (概念)      | ディレクトリ    | 主な責務・内容                                                                   | 依存の方向 |
| :------------------- | :-------------- | :------------------------------------------------------------------------------- | :--------- |
| **Presentation**     | `Views/`        | WPF UI定義 (XAML, Code-behind)。                                                 | ↓ Use Case |
|                      | `ViewModels/`   | Viewの表示データ保持とユーザー操作の受付け。                                     |            |
|                      | `Behaviors/`    | Viewの純粋なUIロジック（添付ビヘイビア）。                                       |            |
| **Use Case**         | `UseCases/`     | アプリケーション固有のルール。複数のService/Modelを組み合わせた手順の記述。      | ↓ Domain   |
| **Domain (Service)** | `Services/`     | 特定の関心事に特化したロジック。外部依存（IO等）を伴うもの。                     | ↓ Models   |
| **Domain (Model)**   | `Models/`       | **中心的なビジネスルール（豊かなドメインモデル）**。データとその振る舞いの保持。 | (最下位)   |
| **Infrastructure**   | `Repositories/` | データの永続化やシステム固有の実装（現在はServiceに内包）。                      | Serviceへ  |

---

## 2. 各レイヤーの詳細規約

### 2.1. ドメインモデル層 (Domain/Model) - **設計の核心**

- **場所**: `src/PageLeaf/Models/`
- **責務**: 単なる「データの器」ではなく、そのデータに関連する**知識と振る舞い**をカプセル化する。
- **豊かなドメインモデルの原則**:
  - 状態（プロパティ）を操作・加工するロジックは、その状態を持つモデル自身に実装する。
  - 不整合な状態（不変条件の違反）を防ぐためのバリデーションや自己構築ロジックを持つ。
  - **例**: `MarkdownDocument` は、自身を保存用テキストに変換する知識や、自身の脚注を整理する知識を持つべきである。

### 2.2. ドメインサービス層 (Domain/Service)

- **場所**: `src/PageLeaf/Services/`
- **責務**: 単一の関心事（ファイル操作、Markdown 変換、CSS 解析など）に特化した純粋なロジックを提供。
- **禁止事項**: モデルに持たせることが自然なロジックを肩代わりすること（貧血症の誘発）。

### 2.3. ユースケース層 (Use Case)

- **場所**: `src/PageLeaf/UseCases/`
- **責務**: ドメインモデルを操作し、ユーザーの目的（開く、保存するなど）を達成する一連のシナリオを記述する。
- **遵守事項**:
  - ロジック自体はドメインモデルに任せ、UseCase はその実行手順（オーケストレーション）に専念する。
  - `IEditorService` などの状態を持つサービスを通じて、アプリの状態を更新する。

### 2.4. プレゼンテーション層 (Presentation)

- **場所**: `src/PageLeaf/Views/`, `src/PageLeaf/ViewModels/`
- **責務**: View と UseCase の仲介。
- **MVVM パターンの遵守**:
  - **WPF 依存の排除**: ViewModel は純粋な C# クラス (POCO) とし、`System.Windows` 名前空間に直接依存してはならない。
  - **型変換の責務**: UI 固有の型への変換は View 側の Converter で行い、ViewModel はプリミティブ型のみを公開する。
- **禁止事項**:
  - **オーケストレーションの禁止**: ViewModel 内で 2 つ以上の Service を組み合わせて複雑な処理フローを組み立ててはならない。
  - **ドメイン知識の保持**: ドメインの内部構造や加工ルールを ViewModel が直接扱ってはならない。

---

## 3. ウィンドウ管理・プレビュー同期

- **IWindowService**: ViewModel から直接 View (Window) を生成・操作することを避け、テスト容易性を確保する。ウィンドウの重複起動防止（Activate制御）を集約する。
- **リロードなしの同期 (Hot-Swapping)**: 引用設定や CSS ファイルの切り替え時、`IEditorService` が発行するイベントを Presentation 層の `WebBrowserHelper` が購読し、WebView2 に対して最小限の JavaScript 命令（DOM操作）を実行することで、高速な同期を実現する。これによりフルリロードによるチラつきや状態喪失を防ぐ。

---

## 4. ロジック漏洩とドメインモデル貧血症の防止

オブジェクト指向の利点を活かし、手続き型のコードによる複雑化を防ぐ。

- **アンチパターン（貧血症）**: 外部の Service がモデルのプロパティを解体・加工してまた戻すような実装。
- **アンチパターン（漏洩）**: ViewModel 内で `_fileService.Open` した結果を `_markdownService.Split` してモデルを再構築するような実装。
- **正しいパターン**: `_openDocumentUseCase.OpenPath(path)` を呼び、UseCase 内部では `Document.Parse(rawText)` のようにモデル自身の振る舞いを利用する。

---

## 5. 実装前の自己検閲リスト (Self-Checklist)

コードを変更（とくに ViewModel を修正）する前に、以下の 4 点を確認すること。

1. **[ ] 振る舞いの所在**: そのロジック（計算、加工、変換）は、操作対象の Model に持たせられないか？
2. **[ ] 手順の重複**: その手順（Open -> Split 等）は他の UseCase ですでに行われていないか？
3. **[ ] サービスの直接操作**: ViewModel で複数の Service を組み合わせて処理（オーケストレーション）を組み立てていないか？
4. **[ ] ドメイン知識の露出**: プレゼンテーション層がドメインの内部構造を直接扱っていないか？
